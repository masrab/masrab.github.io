---
layout: post
title: Analysing Public Recipe Data in R
permalink: /blog/analysing-public-recipe-data-in-R
comments: True
---
```{r, echo=FALSE}
library(knitr)
library(dendextend)
library(tidyr)
library(ggplot2)
library(d3Network)
library(dplyr)
```
<div class="message">
Note: You can view the source of this blog post on github. Here I'll highlight some of the code.
</div>
We are going to use a publicly available recipe dataset to answer one simple question: **Cuisine from which countries are the most similar?** There are of course various ways to answer this question but here I'll be using a rather simplistic view and focus only on the ingredients used in the recipes attributed to each cuisine type.

## The Dataset
The dataset we are working with is a collection recipes scraped from `@website` where each record contains the type of the cuisine (e.g. American, French, Chinese) and the ingredients that were used in the recipe.

The data stored in flat text files where each line is one record. here's the first two lines of the raw data file:
```{r, echo=FALSE}
readLines("../data/epic_recipes.txt") %>% head(2)
```

Before we can use this data in R, we need to read the data into R and convert it to a data frame. First, we combine all the recipes from the same cuisine type together to create a food corpus.
```{r}
# read each line
dat <- readLines("../data/epic_recipes.txt") %>% strsplit(split = "\t")
# extract cuisine and ingredients
cuisine <- sapply(dat, function(x) x[1])
ingredients <- sapply(dat, function(x) paste(x[-1],collapse = " ")) 
# for each cuisine, join together the ingredients from all the recipes
cuisine_names <- cuisine %>% unique
names(cuisine_names) <- cuisine_names
food <- sapply(cuisine_names, function(x){
  ingredients[cuisine == x] %>% paste(collapse = " ")
})
```

The next step is to create a feature matrix from this corpus. One simple way to create features is to represent each cuisine by the number of times each ingredient has been used in it. This is essentially the standard _bag-of-words_ representation often used in text analytics.

```{r}
library(tm)
# convert text corpus to a document term matrix
food_dtm <- VectorSource(food) %>% VCorpus %>% DocumentTermMatrix
# create a data frame from the document term matrix
food_df <- data.frame(cuisine = cuisine_names, stringsAsFactors=FALSE, row.names=NULL) %>% 
  cbind(as.matrix(food_dtm)) %>% tbl_df
```
Here's what the data looks like:
```{r,echo=FALSE}
head(food_df[,1:7])
```

The data is currently in what is known as "wide" format (i.e. each feature is represented as one column). To make our lives easier later on (when plotting the data), let's create a "tall" version of the data as well: 

```{r}
library(tidyr)
# "wide" --> "tall"
food_tall <- food_df %>% gather("ingredient", "count", -cuisine)
```

## Looking at the Data
Once we have the feature matrix, we can use that to find the top ingredients used in each type of food?
  
```{r}
# calculate the ranking of each ingredient for each cuisine type
food_tall <- food_tall %>% group_by(cuisine) %>% 
  mutate(rank = min_rank(desc(count)))
# top N ingredients
food_tall %>% filter(rank<=20) %>% ggplot +
  geom_tile(aes(ingredient, cuisine, fill = rank)) +
  scale_fill_gradient(low="gold", high="red") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5),
        panel.grid = element_blank())
```


```{r, results='asis'}
# top ingredients
food_tall %>% filter(rank<=2) %>% arrange(cuisine, rank) %>% kable
```

If we use the number of unique ingredients used in different cuisine as a measure of _complexity_, we see that `@ABC` is the most complex and `@BAC` has the simplest recipies. 

```{r, results='asis'}
# Number of unique ingredients
food_tall %>% summarise(unique_ingredients = sum(count>0)) %>% 
  arrange(desc(unique_ingredients)) %>% kable
# add plot
```

## Hierarchical Clustering
Without standardizing:
  
```{r}
norm_rows <- function(mat){
  mat / rowSums(mat)
}

hc <- data.frame(food_df, row.names = "cuisine")

# without standardizing
hc %>% dist %>% hclust %>% plot(hang= -1, xlab = "")
```

We need to be careful when using Euclidean distance to measure similarity. We need to standardize rows prior to calculating dissimilarity:
  
```{r}
# need to standardize rows prior to calculating dissimilarity
d <- hc %>% 
  norm_rows %>%
  dist

#hclust(d) %>% plot(hang= -1)

food_dend <- hclust(d) %>% as.dendrogram

num_clusters <- 4
food_dend %>% set("branches_k_color", k = num_clusters) %>% plot

# add bounding boxes
food_dend %>% rect.dendrogram(k=num_clusters, border = 8, lty = 5, lwd = 2)

```

## D3 Forced Network

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
  
```{r}
create_nodes <- function(d, Group = NULL){
  # d: dissimilarity matrix with row names
  if (is.null(Group)) Group <- 1 # all in the same group
  
  nodes <- data.frame(Name = rownames(d), Group = Group)
  
  nodes
  
}


create_links <- function(d){
  node_names <- rownames(d)
  
  d[upper.tri(d, diag = T)] <- NA
  links <- as.data.frame.table(d, responseName = "Value", stringsAsFactors = FALSE)
  colnames(links)[1:2] <- c("Source", "Target")
  
  links$Source <- factor(links$Source, levels = node_names) %>% as.numeric %>% "-"(1)
  links$Target <- factor(links$Target, levels = node_names) %>% as.numeric %>% "-"(1)
  
  # get rid of self-links and duplicates
  links <- links[!is.na(links$Value),] 
  links
}

```

<div id="network1"></div>
  
```{r, results='asis'}
nodes <- as.matrix(d) %>% 
  create_nodes(Group = cutree(food_dend, k = num_clusters))

links <-  as.matrix(d) %>% 
  create_links

d3ForceNetwork(Links = links, Nodes = nodes, Source = "Source",
               Target = "Target", Value = "Value", NodeID = "Name",
               Group = "Group",
               linkDistance = "function(d) { return 1000 * d.value + 10; }",
               linkWidth = "function(d) { return 1/(10*d.value); }",
               charge = -250,
               opacity = 1, 
               standAlone = FALSE,
               parentElement = "div#network1")

```


Not very clear. What if we prune?
```{r}
links <- links %>% filter(Value < quantile(d,.4))
```

We now get this:
  
  <div id="network2"></div>
  
```{r, echo=FALSE, results='asis'}
d3ForceNetwork(Links = links, Nodes = nodes, Source = "Source",
               Target = "Target", Value = "Value", NodeID = "Name",
               Group = "Group",
               linkDistance = "function(d) { return 1000 * d.value + 10; }",
               linkWidth = "function(d) { return 1/(10*d.value); }",
               charge = -250,
               opacity = 1, 
               standAlone = FALSE,
               parentElement = "div#network2")
```


